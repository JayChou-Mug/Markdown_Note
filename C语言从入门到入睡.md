# C语言从入门到入睡

C语言有以下一些主要特点：

*`i)`* 语言简洁、紧凑，使用方便、灵活；

*`ii)`* 运算符丰富；

*`iii)`* 数据类型丰富；

*`iv) `*具有结构化的控制语句；

*`v) `*语法限制不太严格，程序设计自由度大；

*`vi)`* C语言允许直接访问物理地址，能进行位操作，能实现汇编语言的大部分功能，可以对硬件进行操作；

*`vii)`* 用C语言编写的程序可移植性好；

*`viii)`* 生成目标代码质量高，程序执行效率高。

对C语言以上的特点，待学完C语言以后再回顾一下，就会有比较深的体会。

## 1.基本语法

先从最简单的C语言程序入手：

```c
#include<stdio.h>
int main()
{
    printf("This is a C program.\n");
    return 0;
}
```

`main`是函数的名字，表示“主函数”。`return 0` 的作用是：当`main`函数执行结束前将整数0作为函数值返回到调用处。每一个C语言程序都必须有一个main函数。函数体由花括号`{}`括起来。

`printf`是C编译系统提供的函数库中的输出函数。

在使用函数库中的输入输出函数时，编译系统要求程序提供有关此函数的信息（例如对输入输出函数的声明和宏的定义、全局变量的定义等），`#include<stdio.h>`的作用就是来提供这些信息的。

> `stdio.h`是系统提供的一个文件名，stdio是**standard input & output**的缩写，文件后缀.h的意思是头文件**(header file)**，因为这·些文件都是放在程序各文件模块的开头的。
>
> > 输入输出函数的相关信息已事先放到`stdio.h`文件中。

两种注释方法：

以`//`开始的单行注释，如注释内写不下，可以在下一行重新用`//`，然后继续写注释。

以`/*`开始，以`*/`结束的块式注释，这种注释可以包含多行内容。

### 1.1转义字符及其作用

| 转义字符                                 | 字符值                        | 输出结果                               |
| ---------------------------------------- | ----------------------------- | -------------------------------------- |
| `\'`                                     | 一个单撇号`(')`               | 输出单撇号字符'                        |
| `\"`                                     | 一个双撇号`("")`              | 输出双撇号字符""                       |
| `\?`                                     | 一个问号`(?)`                 | 输出一个问号字符?                      |
| `\\`                                     | 一个反斜线`(\)`               | 输出一个反斜线字符\                    |
| `\a`                                     | 警告(alert)                   | 产生声音或视觉信号                     |
| `\b`                                     | 退格(backspace)               | 将光标当前位置后退一个字符             |
| `\f`                                     | 换页(form feed)               | 将光标当前位置移到下一页的开头         |
| `\n`                                     | 换行                          | 将光标当前位置移到下一行的开头         |
| `\r`                                     | 回车(carriage return)         | 将光标当前位置移到本行的开头           |
| `\t`                                     | 水平制表符                    | 将光标当前位置移到下一个Tab位置        |
| `\v`                                     | 垂直制表符                    | 将光标当前位置移到下一个垂直制表对齐点 |
| `\o、\oo或者\ooo`其中o代表一个八进制数字 | 与该八进制码对应的ASCII字符   | 与该八进制码对应的字符                 |
| `\xh[h...]`其中h代表一个十六进制数字     | 与该十六进制码对应的ASCII字符 | 与该十六进制码对应的字符               |

表中倒数第二行是以一个以八进制数表示的字符，例如'\101'代表八进制的101的ASCII字符，即'A'(八进制数101相当于十进制65，ASCII码如下图),具体计算有
$$
\text{八进制的101}\rightarrow1\times8^0+0\times8^1+1\times8^2=1+0+64=\text{十进制的}65
$$
倒数第一行是一个以十六进制数表示的ASCII字符，如`'\x41'`代表十六进制数41的ASCII字符，也是`'A'`。

$$
\Bbb {ASCII码表}
$$

| **ASCII值** | **控制字符** | **ASCII值** | **控制字符** | **ASCII值** | **控制字符** | **ASCII值** | **控制字符** |
| ----------- | ------------ | ----------- | ------------ | ----------- | ------------ | ----------- | ------------ |
| 0           | `NUL`        | 32          | `(space)`    | 64          | `@`          | 96          | `、`         |
| 1           | `SOH`        | 33          | `！`         | 65          | `A`          | 97          | `a`          |
| 2           | `STX`        | 34          | `”`          | 66          | `B`          | 98          | `b`          |
| 3           | `ETX`        | 35          | `#`          | 67          | `C`          | 99          | `c`          |
| 4           | `EOT`        | 36          | `$`          | 68          | `D`          | 100         | `d`          |
| 5           | `ENQ`        | 37          | `%`          | 69          | `E`          | 101         | `e`          |
| 6           | `ACK`        | 38          | `&`          | 70          | `F`          | 102         | `f`          |
| 7           | `BEL`        | 39          | `'`          | 71          | `G`          | 103         | `g`          |
| 8           | `BS`         | 40          | `(`          | 72          | `H`          | 104         | `h`          |
| 9           | `HT`         | 41          | `)`          | 73          | `I`          | 105         | `i`          |
| 10          | `LF`         | 42          | `*`          | 74          | `J`          | 106         | `j`          |
| 11          | `VT`         | 43          | `+`          | 75          | `K`          | 107         | `k`          |
| 12          | `FF`         | 44          | ``,`         | 76          | `L`          | 108         | `l`          |
| 13          | `CR`         | 45          | `-`          | 77          | `M`          | 109         | `m`          |
| 14          | `SO`         | 46          | `.`          | 78          | `N`          | 110         | `n`          |
| 15          | `SI`         | 47          | `/`          | 79          | `O`          | 111         | `o`          |
| 16          | `DLE`        | 48          | `0`          | 80          | `P`          | 112         | `p`          |
| 17          | `DCI`        | 49          | `1`          | 81          | `Q`          | 113         | `q`          |
| 18          | `DC2`        | 50          | `2`          | 82          | `R`          | 114         | `r`          |
| 19          | `DC3`        | 51          | `3`          | 83          | `X`          | 115         | `s`          |
| 20          | `DC4`        | 52          | `4`          | 84          | `T`          | 116         | `t`          |
| 21          | `NAK`        | 53          | `5`          | 85          | `U`          | 117         | `u`          |
| 22          | `SYN`        | 54          | `6`          | 86          | `V`          | 118         | `v`          |
| 23          | `TB`         | 55          | `7`          | 87          | `W`          | 119         | `w`          |
| 24          | `CAN`        | 56          | `8`          | 88          | `X`          | 120         | `x`          |
| 25          | `EM`         | 57          | `9`          | 89          | `Y`          | 121         | `y`          |
| 26          | `SUB`        | 58          | `:`          | 90          | `Z`          | 122         | `z`          |
| 27          | `ESC`        | 59          | `;`          | 91          | `[`          | 123         | `{`          |
| 28          | `FS`         | 60          | `< `         | 92          | `\`          | 124         | `|`          |
| 29          | `GS`         | 61          | `=`          | 93          | `]`          | 125         | `}`          |
| 30          | `RS`         | 62          | `> `         | 94          | `^`          | 126         | `~`          |
| 31          | `US`         | 63          | `?`          | 95          | `—`          | 127         | `DEL`        |

### 1.2运算符

C语言提供以下运算符：

| 算数运算符             | (+ - * / % ++ --)         |
| ---------------------- | ------------------------- |
| **关系运算符**         | **(>< == >= <= !=)**      |
| **逻辑运算符**         | **(! && \|\|)**           |
| **位运算符**           | **(<< >> ~ \| ^ &)**      |
| **赋值运算符**         | **(=及其扩展赋值运算符)** |
| **条件运算符**         | **(?:)**                  |
| **逗号运算符**         | **(,)**                   |
| **指针运算符**         | **(* 和 &)**              |
| **求字节数运算符**     | **(sizeof)**              |
| **强制类型转换运算符** | **( (类型) )**            |
| **成员运算符**         | **(.- >)**                |
| **下标运算符**         | **([ ])**                 |
| **其他**               | **(如函数调用运算符())**  |

其中，算数运算符是自左至右(左结合性)，赋值运算符是自右至左(右结合性)。

**强制类型转换运算符**

可以利用它强制类型转换运算符将一个表达式转换成所需类型，如：

```c
(double) a; //将a转换成double型
(int)(x + y);//将x+y的值转换成int型
(float)(5 % 3);
```

其一般形式为(类型名)(表达式)

### 1.3符号常量

用#define指令，指定一个符号名称代表一个常量，如

```c
#define PI 3.1416 //注意行末没有分号
```

注意，符号常量不是变量。符号常量不占内存，只是临时符号，代表一个值，在预编译后这个符号就不存在了，故不能对符号常量赋新值。为了与变量名相区别，习惯上符号常量用大写表示。

### 1.4常变量

C99允许使用长变量，即在定义变量时，前面加一个关键字`const`，如：

```c
const float pi = 3.1416;
```

定义a为一个整型变量，指定其值为3，而且在变量存在期间其值不能改变。

> 注意，符号常量PI和常变量都代表3.1416，在程序中都能使用，但是二者性质不同。
>
> > 定义符号常量是预编译指令，在编译时仅进行字符替换，在预编译后，符号常量就不存在了(全部替换为3.1416)，对符号常量的名字是不分配储存单元的。
> >
> > 而常变量要占用储存单元，有变量值，只是该值不改变而已。

### 1.5控制语句

控制语句用于完成一定的控制功能。C语言只有9种控制语句，它们的形式是：

> *if()...else...*		(条件语句)
>
> *for()...*				(循环语句)
>
> *while()...*			(循环语句)
>
> *do...while()...*	(循环语句)
>
> *continue*			(结束本次循环语句)
>
> *break*				(中止执行switch或循环语句)
>
> *switch*				(多分支选择语句)
>
> *return*				(从函数返回语句)
>
> *goto*					(转向语句，在结构化程序中基本不用goto语句)

------



## 2.数据类型

### 2.1整形数据

**基本整型(int)**

编译系统分配给int型数据2个字节或4个字节(由具体的C编译系统决定)，Visual C++为每一个整型数据分配4个字节(32个二进制位)。

> 在储存单元中的储存方式是：
>
> > 用整数的补码形式存放。一个整数的补码是此数的二进制形式，如5的二进制是101，如果用两个字节存放一个整数，则在储存单元中数据形式如下
> >
> > | 5的补码： 0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 0 1 |
> > | ------------------------: | :-------------- |
>
> > 如果是一个负数，则应先求出负数的补码(将此数的绝对值写成二进制形式，然后对其所有二进制按位取反，再1)，如下：
> >
> > |     5的原码：             0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 0 1     |
> > | ----------------------------------------: | ------------------- |
> > | **按位取反：            1 1 1 1 1 1 1 1** | **1 1 1 1 1 0 1 0** |
> > |     **再加1(-5的补码)： 1 1 1 1 1 1 1 1** | **1 1 1 1 1 0 1 1** |
>
> 在存放整数的储存单元中，最左面一位是用来表示符号的。该位为0，表示数值为正；该位为1，表示数值为负。

如果给整型变量分配2个字节，则储存单元中能存放的最大值为0111111111111111(第一位是0，其余15位都是1)，此数值为
$$
1\times2^0+1\times2^1+1\times2^2+...+1\times2^{14}={{1\times(1-2^{15})}\over{1-2}}=2^{15}-1
$$
即十进制数32767。最小值为1000000000000000，此数是-2^15，即-32768。因此一个整型变量的值的范围是-32768~32767，超过此范围，就会出现数值的溢出，输出的结果显然不正确。

**短整型(short int)**

类型名为short int或short。短整型分配2个字节。

**长整型(long int)**

类型名为long int或long。长整型分配4个字节。

**双长整型(long long int)**

类型名为long long int或long long，一般分配8个字节。
$$
\text{其实C标准只要求}sizeof(short)\leq sizeof(int)\leq size0f(long)\leq sizeof(long long)\text{即可}
$$

**无符号整型(unsigned  *)**

在实际应用中，有的数据范围常常只有正值。为了充分利用变量的值的范围，可以将变量定义为“无符号”类型。在类型符号前加上修饰符`unsigned`指定该变量是"无符号整数"类型，即有`unsigned int`、`unsigned short`、`unsigned long`、`unsigned long`。而要表示该变量是有符号整数，可以使用`signed`修改，也可以不写(默认就是有符号修饰)。

### 2.2字符型数据

字符与字符代码并不是任意写一个字符，程序都能识别，只能使用系统的字符集中的字符，目前大多数系统采用ASCII字符集。各种字符集的基本集都包括了127个字符，其中包括：

> 字母：a-z[A-Z]
>
> 数字：0-9
>
> 专门符号：能直接在键盘上用英文输入法打出的，共29个
>
> 空格符：空格、水平制表符、垂直制表符、换行、换页
>
> 不能显示的字符：空(null)字符(以\0表示)、警告(以'\a'表示)、退格(以'\b'表示)、回车(以'\r'表示)等

**字符变量(char)**

字符变量实质上是一个字节的整型变量，由于它常用来存放字符，所以称为字符变量。可以把0~127之间的整数赋给一个字符变量。在输出字符变量时，可以选择以十进制整数形式输出，或以字符形式输出，如：

```c
char c = '?';
printf("%d %c\n",c,c); // 63 ?
```

由于字符类型也属于整型，也可以用`signed`和`unsigned`修饰符。

>在使用有符号字符型变量时，允许储存的值为-128~127，但字符的代码不可能为负值，所以在存储字符时实际上只用到0~127这一部分，其第一位都是0。

### 2.3浮点型数据

浮点数类型包括**float**(单精度浮点型)、**double**(双精度浮点型)和**long double**(长双精度浮点型)

**单精度浮点型(float)**

编译系统为每一个float型变量分配4个字节，数值以规范化的二进制指数形式存放在储存单元中。在储存时，系统将实型数据分成小数部分和指数部分两个部分，分别存放。

**双精度浮点型(double)**

为了扩大能表示的数值范围，用8个字节存储一个double型数据，可以得到15位有效数字。为了提高运算精度，在C语言中进行浮点数的运算时，将float型数据都自动转换为double型，然后进行运算。

> 可以在常量的末尾加专用字符，强制指定常量的类型，如：
>
> ```c
> float a = 3.14159f;  //把此3.14159按单精度浮点常量处理，编译时不出现警告。
> long double a = 1.23L;//把此1.23作为long double型处理
> ```

**long double(长双精度浮点型)**

pass

------



## 3.数据的输入输出

编写一个包含输入输出的程序：

```c
#include<stdio.h>
#include<math.h>
int main()
{
double a, b, c,disc, x1, x2, p, q;
scanf("%lf%lf%lf",&a, &b, &c);
disc = b * b - 4 * a * c;
p = -b / (2.0 * a);
q = sqrt(disc) / (2.0 * a);
x1 = p + q;x2 = p - q;
printf("x1=%7.2f\nx2=%7.2\n",x1, x2);
return 0;
}
```

运行结果

```c
1 3 2
x1 = -1.00
x2 = -2.00
```

注意在输入数据时，1，3，2这3个数之间要用空格分隔，最后按回车键。

> 用scanf函数输入a b c值，请注意在scanf函数括号内变量a b c 的前面，要用地址符**&**，如&a代表变量a在内存中的地址。该scanf函数表示从终端输入的3个数据分别送到地址为&a,&b,&c的储存单元，也就是赋给变量a,b,c。双撇号内用%lf格式声明，表示输入的是双精度型实数。

> 在printf函数中，不是简单地用%f格式声明，而是在格式符f的前面加了"7.2"，表示在输出x1、x2时，指数数据占7列，其中小数占2列。

### 3.1printf函数输出语句

在输出时，对不同类型的数据要指定不同的格式声明，而格式声明中最重要的内容是格式字符。常用的有以下几种：

> `%d` 用来输出一个有符号的十进制整数
>
> `%c` 用来输出一个字符
>
> `%s` 用来输出一个字符串
>
> `%f` 用来输出实数(包括单精度、双精度、长双精度)，以小数形式输出，有以下几种写法：
>
> > 基本型`%f` 实数中的整数部分全部输出，小数部分输出6位
> >
> > 指定数据宽度和小数位数`%m.nf`
> >
> > 输出的数据向左对齐`%-m.nf` 当数据长度不超过m时，数据向左靠，右端补空格
>
> `%e` 指定以指数形式输出实数，默认给出数字部分的小数位数为6位，指数部分占5列，如：
>
> >```c
> >printf("%e",123,456); //1.234560 e+0.002
> >						 (6列)   (5列)
> >```
>
> `%u` 用来输出无符号型数据，以十进制整数形式输出。

### 3.2scanf函数输入数据

scanf函数中的格式控制后面应当是变量地址，而不是变量名。

```c
scanf("%f%f%f",&a,&b,&c);
```

如果在格式控制字符串中除了格式声明以外还有其他字符，则**在输入数据时在对应的位置应输入与这些字符相同的字符**，如

```c
scanf("a=%d,b=%d,c=%d\n", &a, &b, &c);
```

在输入数据时，应在对应的位置上输入同样的字符：

```c
a=1,b=2,c=3
```

如果只输入`1 2 3`就错了。系统会把它和scanf函数中的格式字符串逐个字符对照检查，只是在%d的位置上代以一个整型数据。

> 例如在"a=1"的后面输入一个逗号，它与scanf函数中的"格式控制"中的逗号对应。如果输入时不用逗号而用空格或其他字符是不对的。

在用"%c"格式声明输入字符时，空格字符和"转义字符"中的字符都作为有效字符输入，如

```c
scanf("%c%c%c",&c1,&c2,&c3);
```

在执行此函数时应该输入3个字符，中间不要有空格，如`abc`。

若在两个字符间插入空格就不对了，如`a b c`。

系统会把第一个字符'a'送给c1；第2个字符是空格字符' '，送个c2；第3个字符'b'送给c3。而并不是把'a'送给c1，把'b'送给c2，把'c'送给c3。

> 在输入数值数据时，如输入空格，回车，Tab键或遇非法字符，认为该数据结束。

### 3.3putchar函数输出一个字符

putchar(c)的作用是输出字符变量c的值，显然输出的是一个字符。

```c
char a = 'H';char b = 'i';
putchar(a);
putchar(b);
putchar('\n')
//Hi(换行)
```

> 用putchar函数既可以输出能在显示器屏幕上显示的字符，也可以输出屏幕控制字符。
>
> putchar(c)中的c可以是字符常量、整型常量、字符变量或整型变量)(其值在字符的ASCII代码范围内)。

### 3.4getchar函数输入一个字符

getchar函数没有参数，它的作用是从计算机终端(一般是键盘)输入一个字符，并且getchar函数只能接收一个字符，如果想输入多个字符就要用多个getchar函数。

```c
char a,b,c;
a=getchar();
b=getchar();
c=getchar();
putchar(a);
putchar(b);
putchar(c);
//输入 ABC 输出 ABC
```

注意：在连续输入ABC并按`Enter`键之后，字符才会送到计算机中，然后输出ABC3个字符

> 这些字符先暂存在键盘的缓冲器中，只有按下了`Enter`键才会把这些字符一起输入到计算机中，然后按先后顺序分别赋给相应的变量。

### 3.5C++基本的输入输出

C语言使用标准输入输出函数，需要包含头文件`<stdio.h>`。而在C++中，只要包含头文件`<iostream>`，就完全可以使用这些C中的输入输出函数。此外，在`#include<iostream>`还定义了**cin、cout、cerr**和**clog**对象，分别对应于C++的标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。

在使用C++专属的函数前，还需要声明命名空间`using namespace std;`

- **namespace**:是指标识符的各种可见范围。是C++语言特别重要的特性，当第三方供应商提供的库时，为了避免与其他供应商或者用户定义的名字相冲突（命名空间污染），常常将库的内容放置在自己独立的命名空间中。

- **std**:就是C++标准程序库中定义所有标识符的namespace。

#### 3.5.1标准输出cout

cout语句的一般格式为：

```c++
cout << 表达式1 << 表达式2 << …… << 表达式n;
```

语法格式和Java类似，每一个表达式之间通过`<<`进行分隔。如果希望输出完后进行换行，可以在最后一个表达式后添加`endl`(end line)，即

```c++
cout << 表达式 << endl;
```

在用cout输出时,用户不必通知计算机按何种类型输出,系统会自动判别输出数据的类型,使输出的数据按相应的类型输出｡

#### 3.5.2标准输入cin

cin语句的一般格式为：

```c++
cin >> 变量1 >> 变量2 >> …… >> 变量n;
```

在用cin输入时,系统也会根据变量的类型从输入流中提取相应长度的字节：

```c++
char c1,c2;
int a;
float b;
cin >> c1 >> c2 >> a >> b;
```



## 4.选择结构程序设计

### 4.1if语句

```c
if (表达式) 语句1
if (表达式)
	语句1
else
	语句2
if (表达式) 语句1
else if(表达式2) 语句2
else if(表达式3) 语句3
...
else 语句m
```

#### 4.1.1逻辑运算符

| 运算符 | 含义   | 举例     |
| ------ | ------ | -------- |
| &&     | 逻辑与 | a && b   |
| \|\|   | 逻辑或 | a \|\| b |
| !      | 逻辑非 | !a       |

在一个逻辑表达式中如果包含多个逻辑运算符，例如：！a  && b || x>y && c，按以下的优先次序：

> ! -> && -> ||，即'！'是三者中最高的；
>
> && 和 || 低于关系运算符，!高于算数运算符。

#### 4.1.2逻辑表达式

C语言编译系统在表示逻辑运算结果时，用数值1代表"真"，0代表"假"；但在判断一个量是否为"真"时，以0代表"假"，非0代表"真"。即将一个非零的数值认作为真。

#### 4.1.3条件运算符

```c
max=(a>b)?a:b;
```

它代表当a>b时将a的值赋给max；否则将b的值赋给max。条件运算符由两个符号(?或:)组成，必须一起使用。由于它有3个操作对象，被称为三目运算符，也是C语言唯一的一个**三目运算符**。

### 4.2switch语句

```c
switch(表达式)
{
	case 常量1: 语句1
	case 常量2: 语句2
	case 常量3: 语句3
	...
	case 常量n: 语句n
	default: 语句n+1
}
```

一般情况下，在执行一个case子句后，应当用break语句使流程跳出switch结构，终止switch语句的执行。

在case子句中虽然包含了一个以上的执行语句，但可以不必用花括号括起来，会自动顺序执行本case标号后面所有的语句。

------



## 5.循环结构程序设计

### 5.1while语句

```c
while(表达式) 语句
```

只要当循环条件表达式为真，就执行循环体语句。

### 5.2do...while语句

```c
do
{
循环体
}while(表达式)
```

do...while语句是先执行循环体，然后再检查条件是否成立，若成立，再执行循环体。

### 5.3for语句

for语句不仅可以用于循环次数已经确定的情况，还可以用于循环次数不确定而只给出循环结束条件的情况：

```c
for(表达式1;表达式2;表达式3)
	语句
```

> 表达式1：设置初始条件，只执行一次；
>
> 表达式2：循环条件表达式，用来判定是否继续循环。在每次执行循环体前先执行此表达式，决定是否继续执行循环；
>
> 表达式3：作为循环的调整，例如使循环变量增值，它是在执行完循环体后才进行的。

### 5.4改变循环执行的状态

用**break**语句提前终止循环。

用**continue**语句提前结束本次循环：又是并不希望终止整个循环的操作，而只是希望提前结束本次循环，而接着执行下次循环，这时可以用**continue**语句。

------



## 6.数组

### 6.1一维数组

```c
类型说明符 数组名[常量表达式];
```

常量表达式中可以包括常量和符号变量，如int a[3+5]是合法的，但不能包括变量。

**一维数组的初始化**

在定义数组时对全部数组元素赋予初值：

```c
int a[4] = {1,2,3,4};
```

定义a数组有10个元素，但花括号内只提供5个初值，这表示只给前面5个元素赋初值，系统会自动给后5个元素赋初值为0：

```c
int a[10] = {1,3,2,4,5};
```

若想使一个数组中全部元素值为0，可写成：

```c
int a[10] = {0};
```

在对全部数组元素赋初值时，由于数据的格数已经确定，因此可以不指定数组长度：

```c
int a[5] = {1,2,3,4,5};
//等效于
int a[] = {1,2,3,4,5};
```

> 如果在定义数值型数组时，指定了数组的长度并对之初始化，凡未被初始化列表指定初始化的数组元素，系统会自动把它们初始化为0(如果是字符型数组，则初始化为'\0'，如果是指针型数组，则初始化为NULL，即空指针)。

### 6.2二维数组

二维数组常称为矩阵，把二维数组写成行、列的排列方式，可以有助于理解二维数组的逻辑结构：

```c
类型说明符 数组名[常量表达式][常量表达式]
```

例如：

```c
float a[3][4],b[5][10];
```

定义a为`3*4`（3行4列）的数组，b为`5*10`(5行10列)的数组。

C语言对二维数组采用这样的定义方式，使得二维数组可被看作一种特殊的一维数组：它的元素又是一个一维数组。例如，可以把a看作一个一维数组，它有3个元素：

> **`a[0],a[1],a[2]`**

每个元素又是一个包含4个元素的一维数组：

> **`a[0] —— a[0][0] a[0][1] a[0][2] a[0][3]`**
>
> **`a[1] —— a[1][0] a[1][1] a[1][2] a[1][3]`**
>
> **`a[2] —— a[2][0] a[2][1] a[2][2] a[2][3]`**

可以把a[0]，a[1]，a[2]看作3个一维数组的名字，上面定义的二维数组可以理解为定义了3个一维数组。

**二维数组的初始化**

*`i)`* 分行给二维数组赋初值：

```c
int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};
```

这种赋初值的方法比较直观，把第1个花括号内的数据给第1行的元素，第2个花括号内的数据赋给第2行的元素...

*`ii)`* 可以将所有数据写在一个花括号内，按数组元素在内存中的排列顺序对各元素赋予初值：

```c
int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
```

*`iii)`* 可对部分元素赋初值：

```c
int a[3][4] ={{1},{5},{9}};
```

它的作用是只对各行第1列的元素赋初值，其余元素值自动为0。赋值后数组各元素为：

> **`1	0	0	0`**
>
> **`5	0	0	0`**
>
> **`9	0	0	0`**

也可以对各行中的某一元素赋初值：

```c
int a[3][4]={{1},{0，6}，{0，0，11}};
```

初始化后的数组元素如下

> **`1	0	0	0`**
>
> **`0	6	0	0`**
>
> **`0	0	11	0`**

iv) 如果对全部元素都赋初值，则定义数组时对第1维的长度可以不指定，但第2维的长度不能省：

```c
int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
//等效于
int a[][4]={1,2,3,4,5,6,7,8,9,10,11,12};
```

系统会根据总个数和第2维的长度算出第1维的长度

### 6.3字符数组

由于ASCII代码也属于整数形式，因此在C99标准中，把字符类型归纳为整型类型中的一种。C语言中没有字符串类型，也没有字符串变量，字符串是存放在字符型数组中的。

**字符数组的初始化**

对字符数组初始化，最容易理解的方式是用"初始化列表"，把各个字符依次赋给数组中各元素：

```c
char c[10]={'I',' ','a','m',' ','h','a','p','p','y'};
```

把10个字符依次赋给c[0]~c[9]这10个元素中。

> 如果在定义字符数组时不进行初始化，则数组中各元素的值是不可预测的。如果花括号中提供的初值个数小于数组长度，则只将这些字符赋给数组中前面那些元素，其余的元素自动定为空字符`'\0'`(注意不是空格字符）。

如果提供的初值个数与预定的数组长度相同，在定义时可以省略数组长度，系统会自动根据初值个数确认数组长度。

**字符串和字符串结束标志**

在C语言中，是将字符串作为一个字符数组来处理的。在实际工作中，人们关心的往往是字符串的有效长度而不是字符数组的长度。为了测定字符串的实际长度，C语言规定了一个字符串结束标志，以字符***`\0`***作为结束标志。如果字符数组中存在有若干字符，前面9个字符都不是空字符，而第10个是字符`\0`，则认为数组中有一个字符串，有效字符为9个。也就是说，遇到字符`\0`时，表示字符串结束，把它前面的字符组成一个字符串。

> C语言在用字符数组储存字符串常量时会自动加一个`\0`作为结束符。例如"C program"共有9个字符，字符串是存放在一维数组中的，数组中它占10个字节，最后一个字节`\0`由系统自动加上。
>
> > 在执行输出语句时其实系统也在最后一个字符`\n`后面加上了一个`\0`，作为字符的结束标志。运行时，每输出一个字符检查1次，看下一个字符是否为空字符，遇到空字符就停止输出
> >
> > ```c
> > printf("Hello world\n");
> > ```
> >

对C语言处理字符串的方法有以上了解后，再对字符数组初始化的方法补充一种方法，即用字符串常量来使字符数组初始化：

```c
char c[] = {"I am happy"};
//也可以省略花括号
char c[] = "I am happy";
```

注意，此数数组c的长度不是10，而是11。因为字符串常量的最后都由系统加上一个空字符。

**字符串数组的输入输出**

*`i)`* 逐个字符输入输出：使用格式符`%c`

*`ii)`* 将整个字符串一次输入输出：使用格式符`%s`

> 注意，输出的字符中不含结束符`\0`。
>
> 用`%s`格式符输出字符串时，printf函数中的输出项时字符数组名(c)，而不是数组元素名(c[n])
>
> 如果数组长度大于字符串的实际长度，也只输出到遇`\0`结束

另外，可以用scanf函数输入一个字符串：

```c
scanf("%s",c);
```

c是已定义的字符数组名，输入的字符串应短于已定义的字符数组的长度。

如果利用一个scanf函数输入多个字符串，则应在输入时以空格符分隔：

```c
char srt1[5],str2[5],str3[5];
scanf("%s%s%s",str1,str2,str3);
```

输入数据： How are you? [Enter回车]

由于有空格字符分隔，作为3个字符串输入。在输入完后，str1,str2,str3数组的状态如下：

> **str1： `H o w \0 \0`**
>
> **str2：` a r e \0 \0`**
>
> **str3：` y o u ? \0`**

数组中未被赋值的元素的值自动置`\0`。若改为

```c
char str[13];
scanf("%s",str);
```

输入数据： How are you? [Enter回车]

由于系统把空格字符作为一个输入的字符串之间的分隔符，因此只将空格前的字符"How"送到str中。把"How"作为一个字符串处理，故在其后加`\0`。

> 注意，scanf函数中的输入项如果是字符数组名，不要再加地址符&，因为在C语言中数组名代表该数组第一个元素的地址。

#### 6.3.1使用函数处理字符串

**用puts函数输出字符串**

```c
char str[] = "Hello\nworld";
puts(str);
//Hello
//world
```

在用puts输出时将字符串结束标志`\0`转换成`\n`，即输出完毕后换行。

**用gets函数输入字符串的函数**

其作用是从终端输入一个字符串到字符数组，并且得到一个函数值，该函数值是字符数组的起始地址

```c
char str[10];
gets(str);
```

输入数据： computer [Enter回车]

将输入的字符串"computer"送给字符数组str(共9个字符)，返回的函数值是字符数组str的第一个元素的地址。

> 一般利用gets函数的目的是向字符数组输入一个字符串，而不大关心其函数值。

*其实在头文件`<string.h>`下，还提供了很多操作字符串的函数，现提供几种常用的函数：*

**用strcat函数连接字符串**

其作用是把两个字符数组中的字符串连接起来，把字符串2接到字符串1的后面，结果放在字符数组1中，函数调用后得到一个函数值——字符数组1的地址

```c
char str1[30]="People`s Republic of ";
char str2[] = "China";
printf("%s",strcat(str1,str2));
//People`s Republic of China
```

注意，字符数组1必须足够大，以便容纳连接后的新字符串。

> 连接前两个字符串的后面都有`\0`，连接时将字符串1后面的`\0`取消。

**用strcpy函数复制字符串**

其作用是将字符串2复制到字符数组1中去

```c
char str1[10],str2[]="China";
strcpy(str1,str2);
printf("%s",str1);//China
```

> 字符数组1必须定义得足够大，以便容纳被复制的字符串2。

**用strcmp函数比较字符串**

字符串比较的规则是：将两个字符串自左到右逐个字符相比(按ASCII码值大小比较)，直到出现不同的字符或遇到`\0`为止。

*`i) `* 如全部字符相同，则认为两个字符串相等。

*`ii)`*  若出现不同的字符，则以第1对不同的字符的比较结果为准：

> 如果字符串1与字符串2相同，则函数值为0
>
> 如果字符串1>字符串2，则函数值为一个正整数
>
> 如果字符串1<字符串2，则函数值为一个负整数

注意，对两个字符串比较，不能用以下形式：

```c
if(str1>str2)
{
printf("yes");
}
```

因为str1和str2代表地址而不代表数组中的全部元素，而只能用

```c
if(strcmp(str1,str2)>0)
{
printf("yes");
}
```

**用strlen函数测字符串长度**

其作用是测量字符串的真实长度(不包括`\0`在内)

```c
char str[10]="China";
printf("len=%d",strlen(str)); //5
```

**用strlwr函数将字符串转换为小写**

其作用是将字符串中大写字母换成小写字母。

**用strupr函数将字符串转换为大写**

> *注意，库函数并非C语言本身的组成部分，而是C语言编译系统为方便用户使用而提供的公共函数。在使用字符串处理函数时，应当在程序文件的开头用`#include<string.h>`。*

------



## 7.函数

**定义函数**

```c
类型名 函数名(形参表列/无参数)
{
函数体
}
//定义空函数
类型名 函数名()
{}
```

之所以定义空函数，只是这些函数暂时还未编好，先用空函数占一个位置，等以后扩充程序功能时用一个编好的函数代替它。

### 7.1对被调用函数的声明和函数原型

在一个函数中调用另一个函数需具备如下条件：

*`i)`* 首先被调用的函数必须是已经定义的函数(是库函数或用户自己定义好的函数)。但仅有这一条件还不够。

*`ii)`* 如果使用库函数，应该在本文件开头用`#include`指令将调用有关库函数时所需用到的信息"包含"到本文件中来。如：

> *`#include<stdio.h>`*其中，"stdio.h"是一个头文件。在头文件中包含了输入输出库的声明，如果不包含头文件，就无法使用输入输出库中的函数。
>
> 同样，使用数学库中的函数，就应该用*`#include<math.h>`*，h是头文件的后缀，表示是头文件**(header file)**。

*`iii)`* 如果使用用户自己定义得函数，而该函数的位置在调用它的函数(即主调函数)的后面(在同一个文件中)，应该在主调函数中对被调用的函数作声明**(declaration)**。声明的作用是把函数名、函数参数的个数和参数类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别函数并检查调用是否合法。

在函数声明中的形参名可以省写，而只写形参的类型，如

```c
//定义一个函数使两数相加
float add(float x,float y)
{
return x + y;
}
int main()
{//使用函数前的函数声明
float add(float,float);
}
```

> 注意区分"定义"和"声明"。定义是指对函数功能的确立，它是一个完整的、独立的函数单位。而函数的声明的作用则是把函数的名字、类型以及形参类类型等信息通知编译系统，以便在调用该函数时系统按此进行对照检查。

### 7.2函数的嵌套调用

定义函数时，一个函数内不能再定义另外一个函数，即不能嵌套定义*`(在Java中，方法中不能直接定义方法，但可以在方法中定义类，类里面再定义方法)`*，但可以嵌套调用函数，即在调用一个函数的过程中，又调用另一个函数。

### 7.3函数的递归调用

pass

### 7.4数组作为函数调用

调用有参数时，需要提供实参。实参可以是常量、变量或变大时。数组元素的作用与变量相关，一般来说，凡是变量可以出现的地方，都可以用数组元素代替。因此，数组元素也可以用作函数实参，其用法与变量相同，向新参传递数组元素的值。此外，数组名也可作为实参和形参，传递的是数组第一个元素的地址。

#### 7.4.1数组元素作函数实参

在用数组元素作函数实参时，把实参的值传给形参，是"值传递"方式，数据的传递方向是从实参传到形参，单向传递。

#### 7.4.2数组名作为函数参数

> 用数组名作为函数参数时，应该在主调函数和被调函数分别定义数组，不能只在一方定义。
>
> 实参数组和形参数组类型应一致。
>
> 在定义形式参数的数组时，声明形参数组的大小其实是不起任何作用的，因为C语言编译系统并不检查形参数组大小，只是将实参数组的首元素的地址传给形参数组名：
>
> ```c
> //形参数组可以不指定大小
> float add(int array[])
> ```

### 7.5局部变量和全局变量

**局部变量**

在一个函数内定义的变量只有在本函数范围内有效，在此函数以外是不能使用这些变量的。在复合语句内定义的变量只在本复合语句范围内有效，只有本复合语句内才能引用它们。这些称为局部变量。

**全局变量**

在函数之外定义的变量称为外部变量，外部变量就是全局变量。全局变量可以为本文件中其他函数所共用。它的有效范围从定义变量的位置开始到本源文件结束。

### 7.6变量的储存方式和生存期

数据分别存放在静态储存区和动态储存区。全局变量全部存放在静态储存区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不是动态地进行分配和释放。

在动态储存区中存放以下数据：

> *`i)`* 函数形式参数
>
> *`ii)`* 函数中定义的没有用关键字static声明的变量
>
> *`iii)`* 函数调用时的现场保护和返回地址等

对以上这些数据，在函数调用开始时分配储存空间，函数结束时释放这些空间。在程序执行过程中，这种分配和释放是动态的，如果在一个程序中两次调用同一函数，而在此函数中定义了局部变量，在两次调用时分配给这些局部变量的存储空间的地址可能是不相同的。

> 在C语言中，每一个变量和函数都有两个属性，**数据类型**和**数据的存储类别**。存储类别指的是数据在内存中储存的方式(如静态储存和动态储存)。在定义变量和声明函数时，一般应同时指定其数据类型和存储类别，也可以采用默认方式指定(即用户如果不指定，系统会隐含地指定为某一种存储类别)。
>
> > C的存储类别包括4种：***自动的(auto)、静态的(static)、寄存器的(register)、外部的(extern)***

#### 7.6.1自动变量(auto)

函数中的局部变量，如果不专门声明为static存储类别，都是动态地分配存储空间，数据存储在动态存储区中。调用该函数时，系统会给这些变量分配存储空间，在函数调用结束时就自动释放这些存储空间。因此这类局部变量称为**自动变量**：

```c
int f(int a)
{
auto int b,c=3;
...
}
```

实际上，关键字auto可以省略不写。不写auto则隐含指定为"自动存储类别"，它属于动态存储方式。

#### 7.6.2静态局部变量(static)

有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值，即其占用的储存单元不释放，在下一次再调用该函数时，该变量是已有值(就是上一次函数调用结束时的值)。这时就应该指定该局部变量为"静态局部变量"，用关键字static进行声明：

```c
int f(int a)
{
auto int b = 0;//自动局部变量
static int c = 3;//静态局部变量
b++;c++;
return (a+b+c);
}
```

静态局部变量属于静态存储类别，在**静态存储区**内分配存储单元。在程序整个运行期间都不释放。而自动变量属于动态存储类别，分配在动态存储区空间而不再静态存储区空间，函数调用结束后即释放。

> 对静态局部变量是在编译时赋初值的，只赋值一次，在程序运行时它已有初值。以后每一次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。
>
> > 如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0或空字符`\0`。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的内容是不可知的。
>
> > 虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用它。因为它是局部变量，只能被本函数引用，而不能被其他函数引用。

寄存器变量(register)

对于一些使用频繁的变量，可以将其值放在CPU的寄存器中，提高执行效率(寄存器的存取速度远高于内存的存取速度)：

```c
register int f;
```

> 由于现在的计算机的速度愈来愈快，性能愈来愈高，优化的编译系统能够识别使用频繁的变量，从而自动地将这些变量放在寄存器中，而不需要程序设计者指定。因此，现在实际上用register声明变量的必要性不大。

#### 7.6.3全局变量的存储类别

##### 7.6.3.1在一个文件内扩展外部变量的作用域

如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件结束。如果由于某种考虑，在定义点之前的函数需要引用该外部变量，则应该在引用之前用关键字**extern**对该变量作"外部变量声明"，表示把该外部变量的作用域扩展到此位置：

```c
int main()
{
extern int A;
return 0;
}
int A;
```

> 用extern声明外部变量时，类型名可以省写：
>
> ```C
> extern int A;
> //等效于
> extern A;
> ```

##### 7.6.3.2将外部变量的作用域扩展到其他文件

一个C程序可以由一个或者多个源程序文件组成。如果一个程序包含两个文件，在两个文件中都要用同一个外部变量a，不能分别在两个文件中各自定义一个外部变量a，否则在运行程序的连接时会出现"重复定义的错误"。

应当在任一个文件中定义外部变量a，而在另一文件中用**extern**对a作"外部变量声明"，即`extern a`。

> 在编译和连接时，系统会由此直到a有外部链接，可以从别处找到已定义的外部变量a，并将在另一文件中定义的外部变量a的作用域扩展到本文件。
>
> > 在编译时遇到extern时，先在本文件中找外部变量的定义，如果找到，就在本文件中扩展作用域；如果找不到，就在连接时从其他文件中找外部变量的定义。如果从其他文件中找到了，就将作用域扩展到本文件；如果再找不到，就按出错处理。

##### 7.6.3.3将外部变量的作用域限制在本文件中

有时在程序设计中希望某些外部变量只限于被本文件引用，而不能被其他文件引用，这是可以在i当以外部变量时加一个static声明。这样，即使在另一个文件中使用extern查找该变量，仍然不能使用该文件中的变量。

> 用static声明一个变量的作用：
>
> >对局部变量用static声明，把它分配在静态存储区，该变量在整个程序执行期间不释放，其所分配的空间始终存在；
>
> > 对全局变量用static声明，该变量的作用域只限于本文件模块。

注意，用**auto、register、static**声明变量时，是在定义变量的基础上加上这些关键字，而不能单独使用，要与**extern**区分。

#### 7.6.4内部函数和外部函数

函数本质上是全局的，因为定义一个函数的目的就是要被另外的函数调用。如果不加声明的话，一个文件中的函数既可以被本文件中其他函数调用，也可以被其他文件中的函数调用。但是，也可以指定某些函数不能被其他文件调用。根据函数能否被其他源文件调用，将函数区分为**内部函数**和**外部函数**。

**内部函数**

一个函数只能被本文件中其他函数所调用，他称为内部函数，它在定义时在函数名和函数类型的前面加static即可：

```c
static int func(int a);
```

> 内部函数又称静态函数。

**外部函数**

如果在定义函数时，在函数首部的最左端加上关键字extern，则此函数是外部函数，可供其他文件调用

```c
extern int func(int a);
```

> C语言规定，如果在定义函数时省略extern，则默认为外部函数。

------



## 8.指针

如果在程序中定义了一个变量，在对程序进行进行编译时，系统就会给这个变量分配内存单元。编译系统根据程序中定义的变量类型，分配一定长度的空间。内存区的每一个字节有一个编号，这就是"地址"。

> 由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。将地址形象化地称为"**指针**"，意思是通过它能找到以它为地址的内存单元。
>
> > 实际上，C语言中的地址包括位置信息(内存编号，或称纯地址)和它所指向的数据的类型信息，或者说它是带类型的地址。

注意，对变量的访问都是通过地址访问的。

如果有一个变量专门用来存放另一变量的地址(即指针)，则它称为"指针变量"：指针变量就是地址变量，用来存放地址，指针变量的值是地址。

使用指针变量的地址：

```c
#include<stdio.h>
int main()
{
int a=100,b=10;
int *pointer_1,*pointer_2;
pointer_1=&a; //1
pointer_2=&b; //2
printf("a=%d,b=%d\n",a,b); //a=100,b=10
printf("*pointer_1=%d,*pointer_2=%d\n",*pointer_1,*pointer_2); //*pointer_1=100,*pointer_2=10
return 0;
}
```

`//1`、`//2`的作用是使pointer_1指向a，pointer_2指向b，此时pointer_1的值是&a，pointer_2的值是&b；

`*pointer_1`表示"指针pointer_1所指向的变量"，也就是变量a，`*pointer_2`表示"指针pointer_2所指向的变量"，也就是变量b。

**定义指针变量**

```c
类型名 *指针变量名;
int *pointer_1,*pointer_2;
```

左端的int是在定义指针变量时必须指定的"基类型"，用来指定此指针变量可以指向的变量的类型。

> 指向整型数据的指针类型表示为**int***，读作"**指向int的指针**"，或简称"**int指针**"。

### 8.1指针变量作为函数参数

函数的参数不仅可以是整型、浮点型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。

```c
//定义一个函数，交换两个整型数值
#include<stdio.h>
void swap(int *a, int *b)
{
	int temp;
	temp = *a;
	*a = *b;
	*b = temp;
}
int main()
{
	int a = 3,b = 4;
	printf("前：a=%d,b=%d\n", a, b);
	swap(&a, &b);//注意传入的参数不是a和b的值，而是a和b的地址
	printf("后：a=%d,b=%d\n", a, b);
	return 0;
}
/*前：a=3,b=4
后：a=4,b=3*/
```

可以看到，执行swap函数后，变量a和b的值改变了。使用指针变量作为函数参数，在函数执行过程中使指针变量所指向的变量值发生变化，函数调用结束后，这些变量值的变化依旧保留下来。

注意以下代码：

```c
#include<stdio.h>
void swap(int a, int b)
{
	int temp;
	temp = a;
	a = b;
	b = temp;
}
int main()
{
	int a = 3,b = 4;
	printf("前：a=%d,b=%d\n", a, b);
	swap(a, b);
	printf("后：a=%d,b=%d\n", a, b);
	return 0;
}
/*前：a=3,b=4
后：a=3,b=4*/
```

可以发现函数执行之后，并没有真正实现交换的操作。这是因为C语言中实参变量和形参变量之间的数据传递是单向的"值传递"的方式。用指针变量作函数参数时同样要遵循这一规则，但是可以改变实参指针变量所指的变量的值。

### 8.2通过指针引用数组

#### 8.2.1数组元素的指针

一个数组中，每个元素都在内存中占用储存单元，它们都有相应的地址。所谓数组元素的指针就是数组元素的地址。

引用数组元素可以用下标法(a[m])，也可以用指针法，即通过指向数组元素的指针找到所需的元素。使用指针法可以使目标程序质量高。

> 在C语言中，数组名代表数组中首元素的地址，因此，下面两个语句等效：
>
> ```c
> int *p;
> p=&a[0];
> //等效于
> p=a;
> ```
>
> 它的作用是将a数组首元素的地址赋给指针变量p

#### 8.2.2引用数组元素时指针的运算

在指针已指向一个数组元素时，可以对指针进行以下运算：

> 加一个整数(用+或+=)，如p+1
>
> 减一个整数(用-或-=)，如p-1
>
> 自加运算，如p++,++p
>
> 自减运算，如p--,--p
>
> 两个指针相减，如p1-p2(只有p1和p2都指向同一数组中的元素时才有意义)

如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组中的上一个元素。

> 注意，执行p+1时并不是将p的值(地址)简单地加1，而是加上数组元素所占用的字节数，p+1所代表的地址实际上是p+1*d，d是一个数组元素所占的字节数。

[ ]实际上是变址运算符，即将a[i]按a+i计算地址，然后找出此地址单元中的值。

如果指针变量p1和p2都指向同一数组中的元素，如执行p2-p1，结果是p2-p1的值(两个地址的差)处理数组元素的长度。

> 假设p2指向实型数组元素a[5]，p2的值为202(地址)；p1指向a[3]，其值为2012，则p2-p1的结果是(2020-2012)/4=2，表示p2所指的元素于p1所指的元素之间差2个元素。
>
> > - 两个地址不能相加，如p1+p2是无实际意义的。
> >
> > - 如果指针p指向的不是一个数组结构，如链表，是不能通过p$\pm$数字的方式来指向其他元素的。因为对于不同的链表结构体，节点要分配的内存空间是不清楚的。

**通过指针引用数组**

根据以上叙述，引用一个数组元素，可以用以下两种方法

下标法，如`a[i]`形式；

指针法，如`*(a+i)`或`*(p+i)`。其中a是数组名，p是指向该元素的指针变量，其初值是p=a。

以遍历数组为例，可以用以下两种方式：

```c
int a[10] = {...};
for(int i = 0;i<10;i++)
	printf("%d\t",a[i]);
//等效于
for(int *p = a;p < (a+10);p++)
    printf("%d\t",*p);
```

注意，当p不再是局部变量的指针而且后续仍需要用到p时，还需要使p重新指向a[0]

```c
p = a;
```

#### 8.2.3用数组名作函数参数

C编译都是将形参数组名作为指针变量来处理的：

```c
fun(int arr[],int n)
//等价于
fun(int *arr,int n)
```

故函数定时可以写成：

```c
void print(int* arr)
{
	printf("arr[2]=%d\n", *(arr + 2));//等效于printf("arr[2]=%d", arr[2]);
}
int main()
{
	int a[] = { 1,2,3,4,5 };
    //调用函数时传参不必加上*号
	print(a);
	return 0;
}//arr[2]=3
```

当arr接收了实参数组的首元素地址后，arr就指向实参数组首元素，也就是指向`arr[0]`，因此`*arr`就是`arr[0]`(`*(arr + i)`和`arr[i]`是无条件等价的)

#### 8.2.4通过指针引用字符串

通过字符串指针变量指向一个字符串常量，通过字符指针变量引用字符串变量：

```c
char *string="C program";
printf("%s\n",string); //C program
```

对字符指针变量string初始化，实际上是把字符串第1个元素的地址赋给指针变量string，使string指向字符串的第1个字符。

可以对指针变量进行再赋值，如：

```c
string="Java";
```

把字符串"Java"的第一个字符的地址赋给指针变量string，此后string就指向"Java"的第一个字符，不再指向"C program"的第一个字符，因此不能再通过string引用字符串"C program"。

**使用字符指针变量和字符数组的比较**

字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址，绝不是将字符串放到字符指针变量中。另外，可以对字符指针变量赋值，但不能对数组名赋值：

```c
char *a;
a="C program";//合法(赋给a的是字符串第一个元素的地址)
char str[9];
str="C program";//非法(数组名是地址，是常量，不能被赋值)
str[]="C program";//非法(企图把字符串赋给数组中各元素)
```

数组可以在定义时对各元素赋初值，但不能用赋值语句对字符数组中全部元素**整体赋值**。

```c
char str[9];
str[0]='C';//对字符数组元素赋值，合法
```

编译时为字符数组分配若干储存单元，以存放各元素的值，而对字符指针变量，只分配一个储存单元。

字符数组中各元素的值是可以改变的，但字符指针变量指向的字符串常量中的内容是不可以被取代的：

```c
char a[]="House";
char *b="House";
a[2]='r';//合法，r取代a数组元素a[2]的原值u
b[2]='r';//非法，字符串常量不可改变
```

另外，虽然没有定义数组a，但字符串在内存中是以字符数组形式存放的：

```c
char* a = "C progarm";
printf("a[3]=%c\n", a[3]);//等效于printf("a[3]=%c\n", *(a + 3));
//r
```

用指针变量指向一个格式字符串，可以用它代替printf函数的格式字符串：

```c
char *format;
format="a=%d,b=%d\n";
int a=3,b=4;
printf(format,a,b);//等价于printf("a=%d,b=%d\n",a,b);
```

因此只需要改变指针变量format所指向的字符串，就可以改变输入输出的格式。这种printf函数称为可变格式输出函数。

> 也可以用字符数组实现：
>
> ```c
> char format[]="a=%d,b=%d\n";
> printf(format,a,b);
> ```
>
> 但使用字符数组时，只能采用在定义数组时初始化或逐个对元素赋值的方法，不能用赋值语句对数组整体赋值。因此，用指针变量指向字符串的方式更为方便。

#### 8.2.5指向函数的指针

如果在程序中定义一个函数，在编译时会把函数的原代码转换为可执行的代码并分配一段储存空间。这段内存空间有一个起始地址，也称函数的入口地址。每次调用函数时都从该地址入口开始执行此段函数代码。**函数名代表函数的起始地址，调用函数时，从函数名得到函数的起始地址，并执行函数代码。**

函数名就是函数的指针，它代表函数的起始地址。可以定义一个指向函数的指针变量：

```c
int (*p)(int,int);
```

定义p是一个指向函数的指针变量，它可以指向函数类型为整型且有两个整型参数的函数。

通过指针变量调用他所指的函数：

```c
#include<stdio.h>
int max(int x, int y)
{//定义函数，返回两者中较大值
	if (x > y)
		return x;
	else return y;
}
int min(int x, int y)
{//定义函数，返回两者中较小值
	if (x > y)
		return y;
	else return x;
}
int main()
{
	int (*p)(int, int);//定义指向函数的指针变量p
	p = max;//使p指向max函数
	int a = 4,b = 7;
	printf("max=%d\n", p(a, b));
	p = min;//使p指向min函数
	printf("min=%d\n", p(a, b));
	return 0;
}
/*max=7
min=4*/
```

可以看到，在两次printf语句当中，传入的都是`p(a,b)`，但由于两次p的指向不同，所以调用的函数不同。

>注意`int(*p)(int,int)`用来定义p是一个指向函数的指针变量，最前面的int表示这个函数值是整型的。最后面括号中的两个int，表示这个函数有两个int型参数。注意`*p`两侧的括号不可省略，表示p先于*结合，是指针变量。
>
>> 对指向函数的指针变量不能进行算术运算。

#### 8.2.6用指向函数的指针做函数参数

指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数。假设在一个函数内部，又需有调用另一个函数，但每次调用的函数不一致，这时用指针变量就比较方便了：

```c
#include<stdio.h>
int add(int x, int y)//定义函数实现两数相加
{return x + y;}
int subtract(int x, int y)//定义函数实现两数相减
{return x - y;}
int fun(int x, int y, int (*p)(int, int))//定义函数实现两数相加或相减
{(*p)(x, y);}
int main()
{
	int x=5, y=3,num;
	printf("enter 1 ->add,enter 2 ->subtract\n");//输入'1'代表两数相加，输入'2'代表两数相减
	scanf("%d", &num);
	switch (num)
	{//只需要在fun函数内传入add或subtract函数作为参数即可
	case 1: printf("x+y=%d\n", fun(x, y, add)); break;
	case 2: printf("x-y=%d\n", fun(x, y, subtract)); break;
	default:printf("ERROR!\n");
		break;
	}
	return 0;
}
```

输出结果： `1 -> x+y=8` `2 -> x-y=2`

在定义fun函数时，在函数首部用`int (*p)(int,int)`声明形参p使指向函数的指针，该函数是整型函数，有两个整型形参。而在fun函数中的(*p)(x,y)相当于调用add(x,y)或者subtract(x,y)。

从本例可以清楚地看到，不论调用add,subtract，函数fun都没有改变，只是改变实参函数名而已。

------

## 9.动态内存分配

在第7章介绍过全局变量和局部变量，全局变量是在内存中的静态储存区，非静态的局部变量是分配在内存中的动态储存区的，这个储存区是一个称为栈**(stack)**的区域。

除此以外，C语言允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不必在程序的声明部分定义，也不必等到函数结束时才释放，而是需要时随时开辟，不需要时随时释放。这些数据是临时存放在一个特别的自由储存区，称为堆**(heap)**区。可以根据需要向系统申请所需大小的空间。**由于未在声明部分定义它们为变量或数据，因此不能通过变量名或数组名取引用这些数据，只能通过指针来引用。**

### 9.1建立内存的动态分配

对内存的动态分配是通过系统提供的库函数来实现的，主要有下列几种函数：

**malloc函数(memory allocation)开辟动态储存区**

```C
void *malloc(unsigned int size);
```

作用是在内存的动态储存区中分配1个长度为size的连续空间。形参size的类型定位无符号整型。此函数的返回值是所分配区域的第1个字节的地址(此函数是一个指针型函数，返回的指针指向该分配域的第一个字节)：

```C
malloc(100); //开辟100字节的临时分配域，函数值为其第1个字节的地址
```

由于指针的基类型是void，即**不指向任何类型的数据，只提供一个纯地址**。如果此函数未能成功执行(如内存不足)，则会返回空指针NULL。

**calloc函数(clear allocation)开辟动态储存区**

```c
void *calloc(unsigned n,unsigned size);
```

作用是在内存的动态储存区中分配n个长度为size的连续空间，这个空间一般比较大，足以保存一个数组。用calloc函数可以为一维数组开辟动态储存空间，n为数组元素个数，每个元素长度为size，这就是动态数组。函数返回指向所分配域的第1个字节的指针；如果分配不成功则返回NULL。

```C
p = calloc(50,4);  //开辟50 * 4个字节的临时分配域，把首地址赋给指针变量p
```

**realloc函数(reset allocation)重新分配动态储存区**

```C
void *realloc(void *p,unsigned int size);
```

如果已经通过malloc或者calloc函数获得了动态空间，想改变其大小，可以用realloc函数重新分配。用realloc函数将p所指向的动态空间的大小改变为size。p的值不变，如果重分配不成功则返回NULL。

```C
realloc(p,50); //将p所指向的已分配的动态空间改为50字节
```

**free函数释放动态储存区**

```C
void free(void *p);
```

作用是释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。p应是最近一次调用malloc或calloc函数时得到的函数返回值。

```c
free(p); //释放指针变量p所指向的已分配的动态空间
```

*注意free无返回值。*

> 以上4个函数的声明在stdlib.h头文件中，在用到这些函数时应当用`#include<stdlib.h>`指令把stdlib.h头文件包含到程序文件中。

### 9.2void指针类型

C99允许使用基类型为void的指针类型，它不指向任何类型的数据。注意void类型不是指向任何类型的数据，而是**空类型的数据**。在将它的值赋给另一个指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。

在使用malloc,calloc函数时，返回的就是一个**空类型指针**(注意和空指针进行区分)，它不指向任一种具体的类型数据，只提供了一个纯地址。

### 9.3C++中的动态内存分配

除了C库中提供的内存分配函数以外，也可以用C++的方法实现内存的动态分配。

要使用C++的代码前，需要把文件的`.c`后缀改为`.cpp`，因为C++可以完美兼容C语言，所以改了扩展名后并不会使得原先C的代码报错。相反，此时我们可以使用C++的函数和关键字。其中，C++中通过**new**关键字进行动态内存申请，并且动态内存分配是基于类型进行的(与C进行区分)，最后使用**delete**关键字释放内存。

**变量申请**

```C++
Type* pointer = new Type;
//Type指一个已经存在的数据类型
//...
delete pointer;
```

表达式用于分配内存以包含一个Type类型的单个元素。

**数组申请**

```C++
Type* pointer = new Type[N];
//...
delete[] pointer;
```

用于分配Type类型的元素块(数组)，其中N是表示数组长度：

```C++
int *p;
p = new int [5];
```

在这种情况下，系统为int类型的五个元素动态分配空间，并返回指向序列的第一个元素的指针，该指针被分配给指针变量p。 因此，p指向一个有效的内存块，其中包含五个int类型元素的空间。

>由于p是一个指针变量，因此**p指向的第一个元素可以使用表达式`p[0]`或表达式`*p`来访问**。可以使用`p[1]`或`*(p+1)`访问第二个元素，依此类推。

**动态内存分配案例分析**

```c++
#include <stdio.h>
int main()
{
    int* p = new int;
    *p = 15;
    printf("p = %p\n", p);
    printf("*p = %d\n", *p);
    delete p;
    p = new int[10];
    for(int i = 0; i < 10; i++)
    {
        p[i] = i + 1;   
        printf("p[%d] = %d\n", i, p[i]);
    }
    delete[] p;
    return 0;
}
```

运行结果如下：

```C
p = 007F77D8
*p = 15
p[0] = 1
p[1] = 2
p[2] = 3
p[3] = 4
p[4] = 5
p[5] = 6
p[6] = 7
p[7] = 8
p[8] = 9
p[9] = 10
```

### 9.4new关键字与malloc函数的区别

*`i)`* **属性的区别**

​	new/delete：这两个是C++中的关键字，若要使用，需要编译器支持；

​	malloc/free：这两个是库函数，若要使用则需要引入相应的头文件才可以正常使用。

*`ii)`* **使用上的区别**

​	malloc：申请空间需要显式填入申请内存的大小；

​	new：无需显式填入申请的内存大小，new会根据new的类型分配内存。

*`iii)`* **内存位置的区别**

​	new：此操作符分配的内存空间是在自由存储区；

​	malloc：申请的内存是在堆空间。

*`iv)`* **返回类型的区别**

​	new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符；

​	而malloc内存分配成功则是返回`void*`，**需要通过强制类型转换将`void*`指针转换成我们需要的类型**。

*`v)`* **分配失败情况的区别**

​	malloc分配内存失败时返回NULL，可以通过判断返回值可以得知是否分配成功；

​	new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL，分配失败时如果不捕捉异常，程序会异常退出，需要通过异常捕捉的方式获取该异常。

### 9.5使用两种语法格式创建顺序表

初步掌握了C语言和C++的动态内存分配后，分别使用`malloc`函数和`new`关键字创建一个顺序表(一种结构体，相关知识在第10章)，并实现顺序表的初始化，输出线性表的元素和销毁线性表(源文件拓展名为`.cpp`)。如果这一节有看不懂的内容，建议先看第10章结构体再回来看本节。

**自定义结构体类型**

```C++
typedef struct
{
    int* elem; //定义一个int型指针，它用来指向一个数组
    int length;//记录当前线性表长度
}SqList;
```

注意这里的自定义类型`typedef`(10.5节中有介绍)关键字不可省，否则后续的类型转换和识别结构体`SqList`都会报错。

- **通过malloc实现**

需要用到的头文件

```c
#include<stdlib.h>
#include<stdio.h>
```

假设我们已经在主函数中创建了一个线性表的空指针`SqList* L`,调用线性表初始化函数。

**线性表初始化函数**

```C
void InitList(SqList **L)
{
    *L = (SqList*)malloc(sizeof(SqList));
    (*L)->length = 0;
    (*L)->elem = (int* )malloc(sizeof(int) * 100);
}
```

在9.1已经说过，malloc函数返回的指针基类型是void，所以我们需要强制转换成我们需要的类型`(SqList*)malloc(...);`(指向SqList结构体类型的指针)，并且由于malloc函数需要我们手动指定内存大小(单位:字节)，所以用到关键字`sizeof()`得到这个线性表的所占字节数，所以为这个线性表开辟内存的完整表达式写为`(SqList*)malloc(sizeof(SqList))`。

注意在形参中的`L`是一个**二级指针**，即指向指针的指针。由于我们在`main`函数创建的是一个空指针，如果直接把它当作实参，即

```C
void InitList(SqList *L);
```

实际上传递的是指针的副本，而不是指针本身。这导致在`main`函数中，`L`指针仍然是一个未初始化的局部变量。要解决这个问题，需要将`InitList`函数的参数改为指向指针的指针，以便在函数内部修改指针的值；对应的，在`main`函数调用时，并非是简单的把指针传入`SqList *L; InitList(L)`，而是传入指针的地址`InitList(&L)`，**这里不使用指针L的指针(即二级指针)代表L的地址是因为`*L`会被编译器错误解释为指针L所指向地址的实际内容**，所以直接用`&L`代表指针L的地址。

> 注意，在形参中使用地址符`&`是C++的语法，纯C语言是不支持的，所以源文件后缀应当是`.cpp`才可以使用上述语法。

   了解二级指针后，不难发现，在`InitList`函数体内，等式左边的`*L`其实就是一级指针，它才是`main`函数中的`L`。这个时候才可以对它进行初始化。注意这个过程的优先级，需要先用括号括起一级指针，再使用指向运算符(10.3中有介绍)，完整表达式写为`(*L)->成员名=...`。

> elem建立动态内存分配的过程与对线性表L建立动态内存分配相似，不再赘述。

**输出线性表元素**

```c
void PrintList(SqList *L)
{
    for (int i = 0; i < L->length; i++)
    {
        printf("elem[%d]=%d\t", i, L->elem[i]);
    }
}
```

**销毁线性表**

```c
void DestroyList(SqList** L)
{
    (*L)->length = 0;
    free((*L)->elem);
    free(*L);
}
```

*和创建线性表一样，形参是一个二级指针。*

在定义好所有的函数后，开始编写main函数：

```c
int main()
{
    SqList* L;
    InitList(&L);
    //向线性表存入10个数据
    for (int i = 0; i < 10; i++)
    {
        L->elem[i] = i;
        L->length++;
    }
    PrintList(L);
    DestroyList(&L);
    return 0;
}
```

输出内容如下：

```c
elem[0]=0       elem[1]=1       elem[2]=2       elem[3]=3       elem[4]=4       elem[5]=5       elem[6]=6       elem[7]=7       elem[8]=8       elem[9]=9
```

> 假设这个线性表是会多次使用的，也就是说销毁线性表时希望只销毁它里面的数据，而不把表本身销毁掉。如果是这个情况，可以不把L定义为一个指针变量，而是一个结构体类型，代码如下：
>
> ```c
> //形参不再是二级指针，而是传入该线性表结构体的地址
> void InitList(SqList &L)
> {
>     //由于L不再是指针，而是一个真正的结构体，不需要再向内存开辟空间
>     //使用成员运算符而不是指向运算符
>     L.length = 0;
>     //只有L的成员elem需要分配内存
>     L.elem = (int* )malloc(sizeof(int) * 100);
> }
> 
> //由于不涉及到改变线性表本身，形参就是一个结构体
> void PrintList(SqList L)
> {
>     for (int i = 0; i < L.length; i++)
>         printf("elem[%d]=%d\t", i, L.elem[i]);
> }
> 
> //销毁线性表时只是将elem成员的内存释放
> void DestroyList(SqList &L)
> {
>     L.length = 0;
>     free(L.elem);
> }
> int main()
> {
>     //定义的L是一个结构体，不再是一个指针
>     SqList L;
>     InitList(L);
>     for (int i = 0; i < 10; i++)
>     {
>         L.elem[i] = i;
>         L.length++;
>     }
>     PrintList(L);
>     DestroyList(L);
>     return 0;
> }
> ```
>
> > 输出结果不变。
>
> 在这个代码中，只是将`main`函数中的`SqList *L`改为了`SqList L`,但是所有的函数的参数都从原来的指针变成结构体或者结构体的地址，同时从指向运算符变成成员运算符。这样写就不用再考虑是一级指针还是二级指针的问题。

- **通过new实现**

现在再用C++的语法实现这个代码(把L定义成一个结构体类型)。

需要用到的头文件和命名空间的定义(在3.5中介绍过)：

```c++
#include<iostream>
using namespace std;
```

假设我们已经在主函数中创建了一个线性表的变量`SqList L`,调用线性表初始化函数。

**线性表初始化函数**

```c++
void InitList(SqList &L)
{
    L.elem = new int[100];
    L.length = 0;
}
```

> 这里使用了`new`关键字开辟了指定为int类型数据的内存空间。

**输出线性表元素**

```c++
void PrintList(SqList L)
{
    for (int i = 0; i < L.length; i++)
        cout << "elem[" << i << "]=" << L.elem[i] << "\t";
}
```

> 使用了C++的标准输出函数。

**销毁线性表**

```c++
void DestroyList(SqList& L)
{
    L.length = 0;
    delete[] L.elem;
}
```

> 使用delete释放一个变量开辟出的内存时，使用`delete 对象名;`，若释放一个数组的内存，则使用`delete[] 对象名;`

主函数：

```C++
int main()
{
    SqList L;
    InitList(L);
        for (int i = 0; i < 10; i++)
    {
        L.elem[i] = i;
        L.length++;
    }
    PrintList(L);
    DestroyList(L);
    return 0;
}
```

输出结果仍然不变。

> 在实际应用上，建议使用纯C++的内存分配语法或者纯C语言内存分配语法，而不要将两种语法混在一起使用。

## 10.结构体

C语言允许用户自己建立由不同类型数组组成的组合型的数据结构，它称为结构体。在其他一些高级语言中称为记录。

```c
struct Student
{
int num;
char name[20];
char gender;
int age;
};
```

经过上面的指定，struct Student就是一个在本程序中可以使用的合法类型名。它由编译系统声明：这是一个结构体类型。

> 花括号内是该结构体所包含的子项，称为结构体的成员。上例中的num、name、gender等等都是成员，对各成员都应进行类型声明。
>
> > 成员表列也称域表，每一个成员是结构体中的一个域。

结构体类型并非只有1种，而是可以设计出许多种结构体类型：

```c
struct Date
{
int month;
int day;
int year;
};
struct Student
{
int num;
char name[20];
char gender;
int age;
struct Date birthday//成员birthday属于struct Date类型
};
```

前面只是建立了一个结构体类型，它相当于一个模型，并没有定义变量，其中无具体数据，系统对之也不分配储存单元。

### 10.1结构体变量的初始化和引用

在定义结构体变量时，可以对它初始化，即赋予初始值：

```c
#include<stdio.h>
struct Student
{
	int num;
	char name[20];
	char gender;
	int age;
}stu1 = {12,"John",'m',19};
int main()
{
	printf("stu1.num=%d\n", stu1.num);
	printf("stu1.name=%s\n", stu1.name);
	printf("stu1.gender=%c\n", stu1.gender);
	printf("stu1.age=%d\n", stu1.age);
}
/*stu1.num=12
stu1.name=John
stu1.gender=m
stu1.age=19*/
```

> 注意：`stu1.num`表示变量stu1中的num成员
>
> 初始化列表是用花括号括起来的一些常量，这些常量依次赋给结构体变量中的各成员。
>
> 未被指定初始化的数值型成员会被系统初始化为0，字符型成员会被系统初始化为`\0`，指针型成员会被系统初始化为NULL。
>
> **用结构体名字去定义声明的变量是一个真正的变量，他在内存中分配有自己的存储空间。**

可以引用结构体变量中成员的值，如`stu1.num`表示stu1变量中的num成员，在程序中可以对变量的成员赋值，如：

```c
stu1.num=1;
//由于字符数组中存储的字符串中常量，是无法通过stu1.name="xxx"修改的，但可以使用字符串复制函数赋值
strcpy(stu1.name, "xxx");
//或使用getchar()一个字符一个字符赋值
```

> "."是成员运算符，它在所有的运算符中优先级最高，因此可以把`stu1.num`作为一个整体来看待，相当于一个变量。

如果成员本身又属一个结构体类型，则要用若干个成员运算符，一级一级地找到最低的一级成员，只能对最低级的成员进行赋值或存取以及运算：

```c
stu1.birthday.month=5;
```

对结构体变量的成员可以像普通变量一样进行各种运算(根据其类型决定可以进行的运算)，如赋值、自增、加法运算；另外，同类的结构体可以互相赋值：

```c
struct stu2;
stu2=stu1;
```

可以引用结构体变量成员的地址：

```c
printf("enter your name and age:\n");
scanf("%s",stu1.name);
scanf("%d",&stu1.age);
```

注意`stu1.name`前面没有&，这是因为name是数组名，本身就代表地址，故不能画蛇添足再加一个&。

如果使用一个指针变量指向一个结构体，可以通过这个指针完成初始化：

```C
typedef struct Stu
{
	int num;
}Stu;

int main()
{
    LNode *S;
    printf("S->num=");
    scanf("%d",&(S->num));
    return 0;
}
```



### 10.2使用结构体数组

一个结构体变量可以存放一组有关联的数据，如果这些数据需要参加运算，可以考虑使用数组，这就是结构体数组。

```c
struct 结构体名
{成员表列} 数组名[数组长度];
```

将3位学生的成绩信息存入一个数组：

```c
#include<stdio.h>
struct List
{
	char name[10];
	int score;
};
int main()
{
	struct List list[3] = {"Tifa",100,"Aerith",97,"Cloud",75};
	for (int i = 0; i < 3; i++)
		printf("name:%s\tscore:%d\n", list[i].name, list[i].score);
}
/*name:Tifa       score:100
name:Aerith     score:97
name:Cloud      score:75*/
```

### 10.3结构体指针

所谓结构体指针就是指向结构体变量的指针，一个结构体变量的起始地址就是这个结构体变量的指针。如果把一个结构体变量的起始地址存放在一个指针变量中，那么这个指针变量就指向该结构体变量。

**指向结构体变量的指针**

指向结构体对象的指针变量既可以指向结构体变量，也可以指向结构体数组中的元素，指针变量的基类型必须与结构体变量的类型相同。

```c
struct Student *pt//pt可以指向struct Student类型的变量或数组元素
```

**指向结构体数组的指针**

可以使用指针变量指向结构体数组中的元素。现修改上述`将3位学生的成绩信息存入一个数组`的代码：

```c
#include<stdio.h>
struct List
{
	char name[10];
	int score;
}list[3] = { "Tifa",100,"Aerith",97,"Cloud",75 };
int main()
{//遍历每一位学生的数据
	for (struct List* p = list; p < list + 3; p++)
		printf("name:%s\tscore:%d\n", p->name, p->score);
	return 0;
}
/*name:Tifa       score:100
name:Aerith     score:97
name:Cloud      score:75*/
```

其中`p->name`或`p->score`的作用等效于`(*p).name`和`(*p).score`，表示p所指向的结构体变量中的name或score变量，`->`称为**指向运算符**，使用指向运算符比成员运算符更直观。

> 如果p指向一个结构体变量`stu`，以下三种用法等价：
>
> > `stu.成员名`
> >
> > `(*p).成员名`
> >
> > `p->成员名`

### 10.4用结构体变量和结构体变量的指针作函数参数

将一个结构体变量的值传递给另一个函数，有3个方法：

> *`i)`* 用结构体变量的成员做参数，用法和普通变量一致。
>
> *`ii)`* 用结构体变量做参数，这种传递方式在空间和时间上开销较大：
>
> > 将结构体变量所占的内存单元的内容全部按顺序传递给形参，形参必须是同类型的结构体变量，在函数调用期间形参也要占用内存单元。
>
> *`iii)`* 用指向结构体变量的指针作实参，将结构体变量的地址传给形参。

思考一个场景：先录入N个学生的数据，每个数据包括了学生名字、3个科目的成绩以及平均分。现需要找到平均分最高的学生，并输出他的所有数据：

```c
#include<stdio.h>
//考虑N=3的情况
#define N 3
struct List
{
	char name[10];
	int score[3];
	int average;
}stu[N], *p;//定义结构体数组和指针
int main()
{
	p = stu;//使指针p指向stu数组的首元素
    //函数声明(声明时并不关心数据类型的实际名称)
	void input(struct List []);
	int max(struct List []);
    void print(struct List *);
	input(p);
	print(p+max(p));
	return 0;
}
//定义函数录入数据
void input(struct List list[])
{
	for (int i = 0; i < N; i++)
	{
		printf("请输入第%d个学生的名字，3科成绩：", i + 1);
        //输入数据，注意按照格式控制(这里是一个元素一个空格)来输入
		scanf("%s %d %d %d", list[i].name, &list[i].score[0], &list[i].score[1], &list[i].score[2]);
		list[i].average = (list[i].score[0] + list[i].score[1] + list[i].score[2]) / 3;
	}
}
//定义函数找到均分最高的学生对应的结构体数组索引
int max(struct List list[])
{
	int index = 0;
	int max = list[index].average;
	for (int i = 1; i < N; i++)
	{
		if (max < list[i].average)
		{
			max = list[i].average;
			index = i;
		}
	}
	return index;
}
//定义函数输出信息
 void print(struct List *p)
 {printf("平均分最高的学生是%s，三科成绩分别为%d，%d，%d\n",p->name,p->score[0],p->score[1],p->score[2]);}
/*运行结果：
请输入第1个学生的名字，3科成绩：Tifa 100 100 100
请输入第2个学生的名字，3科成绩：Aerith 100 80 90
请输入第3个学生的名字，3科成绩：Cloud 60 70 80
平均分最高的学生是Tifa，三科成绩分别为100，100，100*/
```

注意这三个函数的实参和形参：

> `input`、`max`函数的形参都是一个`List`结构体的数组，但它们的实参都是一个指向`stu`数组的结构体指针。这个指针变量指向`stu`中首个元素的地址。
>
> > 在`input`函数中调用了`scanf`函数，分别将学生名字、三科成绩使用成员运算符`"."`赋给了对应的成员变量。
>
> 在录入数据后，`print(p+max(p));`这个语句：
>
> > *`i)`* 首先找到均分最高的学生他在stu结构体数组中对应的下标`index`。
> >
> > *`ii)`* 由于`p`是**指针**，`p+index`代表该指针指向这个均分最高的学生在`stu`结构体中的地址。
> >
> > *`iii)`* 将这个地址传给`print`函数，该函数可以通过指向运算符`->`访问到结构体中的成员。

### 10.5使用typedef声明新类型名

除了可以直接使用C提供的标准类型名和自己编写的结构体、共用体和枚举类型外，还可以用typedef指定新的类型名来代替已有的类型名。

- 简单地用一个新类型名代替原有的类型名

```C
typedef int Integer; //指定Integer为类型名，作用与int相同
```

则有

```c
int i,j;
//等效于
Integer i,j;
```

- 命名一个简单的类型名代替复杂的类型表示方法

```c
typedef struct
{
int month;
int day;
int year;
}Date;
```

以上声明了一个新的类型名Date，代表上面的一个结构体类型，然后可以用新的类型名Date去定义变量：

```c
Date Birthday; //等效于struct Date Birthday
Date *p; //等效于struct Date* p
```

> 命名一个新的类型名代表数组类型
>
> ```c
> typedef int Num[100];
> Num a; //定义a为整型数组名，它有100个元素
> ```
>
> 命名一个新的类型名代表指针类型
>
> ```c
> typedef char* String;
> String p,s[10]; //定义p为字符指针变量，s为字符指针数组
> ```

归纳起来，声明一个新的类型名方法是：

*`i)`*先按定义变量的方法写出定义体(int i;)

*`ii)`*将变量名换成新类型名(将i换成Count)

*`iii)`*在最前面加typedef(typedef int Count)

> 习惯上，常把用typedef声明的类型名的第一个字母大写表示，与系统提供的标准类型标识符进行区别。

当不同源文件中用到同一类型数据时，常用typedef声明一些数据类型。可以把所有的typedef名称声明单独放在一个头文件中，然后在需要用到它们的文件中用`#include`指令把它们包含到文件中。这样就不需要在各文件中自己定义typedef名称了。

## 11.共用体

有时想用同一段内存单元存放不同类型的变量，例如把一个`short int`变量、一个`char`变量和一个实型变量放在同一个地址开始的内存单元中。以上3个变量在内存中占的字节数不同,但都从同一地址开始存放，也就是使用覆盖技术,后一个数据覆盖了前面的数据。这种使几个不同的变量共享同一段内存的结构，称为共用体类型的结构。

### 11.1共用体的初始化和引用

共用体的定义如下：

```C
union Data
{
int i;
char ch;
float f;
}a;
```

可以看到，“共用体”与“结构体”的定义形式相似，但它们的含义并不同。
**结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元；而共用体变量所占的内存长度等于最长的成员的长度。**

只有先定义了共用体变量才能引用它，前面定义了`a`为共用体变量，正确的引用方式为:`a.i` `a.ch` `a.f`。不能只引用共用体变量，例如下面的引用是错误的：

```c
printf("%d",a);
```

因为a的存储区可以按不同的类型存放数据，如果仅写共用体变量名a，系统无法知道究竟应输出哪一个成员的值。应该写成：

```c
printf("%d" , a.i) ;
//或
printf("%c", a.ch) ;
```

### 11.2共用体类型数据的特点

在使用共用体类型数据时要注意以下一些特点:

*`i)`* 同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员而不是同时存放几个。因为在每一个瞬时，存储单元只能有唯一的内容，即在共用体变量中只能存放一个值。如果有以下程序段:

```c
union Date
{
int i;
char ch;
float f;
}a;
a.i=97;
```

表示将整数97存放在共用体变量中,可以用以下的输出语句:

```c
printf("%d" ,a.i) ;//输出整数97
printf("%c", a.ch) ;//输出字符'a'
printf("%f" ,a.f) ;//输出实数0.000000
```

由于97是赋给`a.i`的，因此按整数形式存储在变量单元中，最后一个字节是“01100001”。如果用`%d`格式符输出`a.i`,就会输出整数97。如果想用`%c`格式符输出`a.ch`，系统会把存储单元中的信息按字符输出`'a'`。如果想用`%f`格式符输出`a.f`，系统会将存储单元中的信息按浮点数形式来处理，其数值部分为0，故输出0.000000。



*`ii)`*可以对共用体变量初始化，但初始化表中只能有一个常量。下面用法不对:

```c
union Data
{
int i;
char ch;
float f;
}a={1,'a',1.5};//不能初始化3个成员，它们占用同一段存储单元
union Data a={16};//合法
```



*`iii)`* 共用体变量中起作用的成员是最后一次被赋值的成员,在对共用体变量中的一个成员赋值后，原有变量存储单元中的值就被取代。如果执行以下赋值语句:

```c
a.ch = 'a';
a.f = 1.5;
a.i = 40;
```

在完成以上3个赋值运算以后，变量存储单元存放的是最后存人的40，原来的'a'和1.5都被覆盖了。此时如用`printf("%d",a.i)`输出`a.i`的值是40。而用`printf("%e",a.ch)`输出的不是字符`'a'`,而是字符`'('`。因为在共用的存储单元中，按整数形式存放了40，现在要长%c格式输出`a. ch`,系统就到共用的存储单元去读数据，将存储单元中的内容按存储字符据的规则解释，40是字符`'('`的ASCII码,因此输出字符`'('`。

> *注意，在给共用体变量赋值时，系统会先把内容赋给共用体的每一个成员。如果赋值失败，则该成员保持默认值，如`int`的默认值是`0`，`float`的默认值是`0.0`，`char`的默认值是`'\0'`*：
>
> ```c
> union Data
> {
> 	int i;
> 	char c;
> 	float f;
> } a;
> int main()
> {
> 	union Data a = {4.13};
> 	printf("a.i=%d\n", a.i);
> 	printf("a.c=%c\n", a.c);
> 	printf("a.f=%f\n", a.f);
> 	return 0;
> }
> ```
>
> 运行结果：
>
> ```c
> a.i=4
> a.c=
> a.f=0.000000
> ```



*`iv)`*共用体变量的地址和它的各成员的地址都是同一地址。例如,`&a.i`,`&a.c`,`&a.f`都是同一值。



*`v)`*不能对共用体变量名赋值，也不能企图引用变量名来得到一个值。



*`vi)`*共用体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型定义中，数组也可以作为共用体的成员。

> 基于这一特性，我们可以实现广义表的存储结构。其形式定义说明如下：
>
> ```c
> typedef enum {ATOM,LIST} ElemTag; // ATOM == 0: 原子;LIST == 1: 子表
> typedef struct GLNode
> {
>     ElemTag tag;// 公共部分，用于区分原子结点和表节点
>     union// 原子节点和表节点的联合部分
>     {
>         AtomType atom; // atom是原子节点的直域，AtomType由用户定义
>         struct
>         {
>             struct GLNode *hp,*tp;// ptr是表节点的指针域
>         }ptr;
>     };
> }*GList;
> ```
